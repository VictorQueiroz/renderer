var registry = directiveRegistry;

function compile(node, transcludeFn, maxPriority) {
  var nodes;

  if(isArray(node) || (node instanceof NodeList === true)) {
    nodes = node;
    node = null;
  } else {
    nodes = [];
    nodes.push(node);
  }

  var compositeLinkFn = compileNodes(nodes, transcludeFn, maxPriority);

  return publicLinkFn;

  function publicLinkFn (scope, cloneConnectFn) {
    var linkNodes;

    if(cloneConnectFn) {
      var clones = new Array(nodes.length);

      for(var i = 0; i < clones.length; i++) {
        clones[i] = nodes[i].cloneNode(1);
      }

      linkNodes = clones;
    } else {
      linkNodes = nodes;
    }

    if(cloneConnectFn) cloneConnectFn(linkNodes, scope);
    if(compositeLinkFn) compositeLinkFn(scope, linkNodes);

    return linkNodes;
  }
}

function replaceWith (node, replaceElement) {
  var parent = node.parentNode;

  if(parent) {
    parent.replaceChild(replaceElement, node);
  }
}

/**
 * Apply a set of directives to a node element:
 *  - Execute the compile function of all the directives instances
 *  - Store the retrieved linking functions from the execution of the compile function
 *
 * Returns the node link function
 */
function apply(directives, node, attributes, transcludeFn) {
  var i,
      ii,
      linkFn,
      directive,
      directiveValue,
      terminalPriority = -Number.MAX_VALUE,
      childTranscludeFn = transcludeFn;

  // pre/post links
  var preLinkFns = [],
      postLinkFns = [];

  for(i = 0, ii = directives.length; i < ii; i++) {
    directive = directives[i];

    if(terminalPriority > directive.priority) {
      break; // prevent further processing of directives
    }

    if(directiveValue = directive.transclude) {
      if(directiveValue == 'element') {
        terminalPriority = directive.priority;

        var template = node;

        node = document.createComment(' ' + directive.name + ': ' + attributes[directive.name] + ' ');
        replaceWith(template, node);

        childTranscludeFn = compile(template, transcludeFn, terminalPriority);
      } else {
        var template = new Array(node.childNodes.length);

        for(var i = 0; i < template.length; i++) {
          template[i] = node.childNodes[i];
        }

        // child nodes naked transclude function generated
        childTranscludeFn = compile(template, transcludeFn);
      }
    }

    if(directiveValue = directive.template) {
      node.innerHTML = directive.template;
    } else if (directive.transclude && directive.transclude !== 'element') {
      node.innerHTML = '';
    }

    linkFn = directive.compile(node, attributes, childTranscludeFn);

    if(isFunction(linkFn)) {
      addLinkFn(0, linkFn);
    } else if(isObject(linkFn)) {
      addLinkFn(linkFn.pre, linkFn.post);
    }

    if(directive.terminal) {
      nodeLinkFn.terminal = true;
      terminalPriority = Math.max(terminalPriority, directive.priority); // make sure to always get the bigger priority
    }
  }

  function addLinkFn (pre, post, directive) {
    if(pre) {
      preLinkFns.push(pre);
    }

    if(post) {
      postLinkFns.push(post);
    }
  }

  // store the transclude function generated by this node link function
  // so we can pass to the compileNodes() while generating the composite link function
  // to the child nodes of this element in the next lines on the actual compileNodes() loop
  nodeLinkFn.transcludeFn = childTranscludeFn;

  return nodeLinkFn;

  /**
   *  - Executes the pre and post linking functions
   */
  function nodeLinkFn (scope, node, childLinkFn, transcludeFn) {
    var i,
        linkFn;

    for(i = 0; i < preLinkFns.length; i++) {
      linkFn = preLinkFns[i];
      invokeLinkFn(linkFn,
        scope,
        node,
        attributes,
        null,
        transcludeFn ? scopeBoundTranscludeFn : undefined
      );
    }

    if(childLinkFn) {
      childLinkFn(scope, node.childNodes);
    }

    for(i = postLinkFns.length - 1; i >= 0; i--) {
      linkFn = postLinkFns[i];
      invokeLinkFn(linkFn,
        scope,
        node,
        attributes,
        null,
        transcludeFn ? scopeBoundTranscludeFn : undefined
      );
    }

    // bound the transcludeFn to the above passed scope, so we didn't have
    // to pass the scope as we should in a naked transclude function
    function scopeBoundTranscludeFn($scope, cloneAttachFn) {
      if(isFunction($scope)) {
        cloneAttachFn = $scope;
        $scope = scope;
      }

      transcludeFn($scope, cloneAttachFn);
    }
  };
}

function invokeLinkFn(linkFn, scope, node, attributes, controllers, transcludeFn) {
  linkFn(scope, node, attributes, controllers, transcludeFn);
}

function addDirective(name, type, directives, maxPriority) {
  var i,
      ii,
      instances,
      directive;

  if((instances = registry.$$get(name))) {
    for(i = 0, ii = instances.length; i < ii; i++) {
      directive = instances[i];

      if((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.type.indexOf(type) > -1) {
        directives.push(directive);
      }
    }
  }
}

/**
 * Sorting function for bound directives.
 */
function byPriority(a, b) {
  var diff = b.priority - a.priority;
  if (diff !== 0) return diff;
  if (a.name !== b.name) return (a.name < b.name) ? -1 : 1;
  return a.index - b.index;
}

function scan(node, directives, attributes, maxPriority) {
  var i,
      ii,
      name,
      attr,
      attrs,
      classes;

  switch(node.nodeType) {
    case Node.ELEMENT_NODE: /* Element */
      name = camelCase(node.tagName),
      attrs = node.attributes,

      // Element tag name
      addDirective(name, 'E', directives, maxPriority);

      for(i = 0, ii = attrs.length; i < ii; i++) {
        attr = attrs[i];
        name = camelCase(attr.name);

        attributes[name] = attr.value;

        // Attributes
        addDirective(name, 'A', directives, maxPriority);
      }

      classes = node.classList;

      for(i = 0, ii = classes.length; i < ii; i++) {
        name = camelCase(classes[i]);

        // Classes
        addDirective(name, 'C', directives, maxPriority);
      }

      break;
  }

  directives.sort(byPriority);
}

function compileNodes(nodeList, transcludeFn, maxPriority) {
  var i,
      linkFns = [],
      childLinkFn,
      linkFnFound,
      nodeLinkFnFound;

  // node link function variables
  var directives,
      nodeLinkFn,
      attributes;

  for(i = 0; i < nodeList.length; i++) {
    directives = [],
    attributes = new Attributes();

    scan(nodeList[i], directives, attributes, i === 0 ? maxPriority : undefined);

    nodeLinkFn = directives.length ? apply(directives, nodeList[i], attributes, transcludeFn) : null;

    // Check if the node link is terminal or have child nodes to be compiled.
    // If it's a terminal node link function it means that a set of directives
    // must be compiled before the rest of them, according to the priority level
    // The highest priority level directive will be compiled first (as it should)
    // until it reach the terminal directive instance which generates a transclude
    // function to be executed later
    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) &&
                  nodeList[i] &&
                  nodeList[i].childNodes &&
                  nodeList[i].childNodes.length;

    childLinkFn = childLinkFn ? compileNodes(nodeList[i].childNodes, nodeLinkFn && nodeLinkFn.transcludeFn ? nodeLinkFn.transcludeFn : transcludeFn) : null;

    if(childLinkFn || nodeLinkFn) {
      linkFnFound = true;
      nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;

      linkFns.push(i, nodeLinkFn, childLinkFn);
    }
  }

  return (linkFnFound ? compositeLinkFn : null);

  function compositeLinkFn (scope, nodeList) {
    var i,
        node,
        nodeLinkFn,
        childLinkFn,
        transcludeFn,
        stableNodeList;

    // copy node list so if the node link adds or remove a dom element our
    // offsets don't get screw up
    if(nodeLinkFnFound) {
      var idx,
          nodeListLength = nodeList.length;

      stableNodeList = new Array(nodeListLength);

      for(i = 0; i < linkFns.length; i += 3) {
        idx = linkFns[i];
        stableNodeList[idx] = nodeList[idx];
      }
    } else {
      stableNodeList = nodeList;
    }

    for(i = 0; i < linkFns.length;) {
      node = stableNodeList[linkFns[i++]];
      nodeLinkFn = linkFns[i++];
      childLinkFn = linkFns[i++];
      transcludeFn = nodeLinkFn && nodeLinkFn.transcludeFn;

      if(nodeLinkFn) {
        nodeLinkFn(scope, node, childLinkFn, transcludeFn);
      } else if (childLinkFn) {
        childLinkFn(scope, node.childNodes, transcludeFn);
      }
    }
  }
}
